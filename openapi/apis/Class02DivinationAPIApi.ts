/* tslint:disable */
/* eslint-disable */
/**
 * 냥팔자 API 명세
 * 냥파자는 상팔자 어플리케이션을 위한 API 명세서입니다. - 모든 API의 Path는 **\'/api\'로 시작**합니다. - 모든 API의 응답은 **공통 응답 형식**을 가집니다. data에 실제 응답 데이터가 들어갑니다.     ```json     {       \"requestId\": \"서버생성 요청ID\",       \"requestTime\": \"요청시간\",       \"success\": \"성공여부\",       \"data\": {         JSON 데이터       }     }     ```
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    DefaultResponse,
    DefaultResponseFromJSON,
    DefaultResponseToJSON,
    DivinationQuestionListReqeustDto,
    DivinationQuestionListReqeustDtoFromJSON,
    DivinationQuestionListReqeustDtoToJSON,
    DivinationQuestionListResponseDto,
    DivinationQuestionListResponseDtoFromJSON,
    DivinationQuestionListResponseDtoToJSON,
    DivinationQuestionResponseDto,
    DivinationQuestionResponseDtoFromJSON,
    DivinationQuestionResponseDtoToJSON,
    DivinationQuestionSolveCheckResponseDto,
    DivinationQuestionSolveCheckResponseDtoFromJSON,
    DivinationQuestionSolveCheckResponseDtoToJSON,
} from '../models';

export interface CheckDivinationDoneRequest {
    questionId: string;
}

export interface DoDivinationRequest {
    questionId: string;
}

export interface GetDivinationQuestionDetailRequest {
    questionId: string;
}

export interface GetDivinationQuestionsRequest {
    request: DivinationQuestionListReqeustDto;
}

export interface GetDivinationResultRequest {
    resultId: string;
}

/**
 * 
 */
export class Class02DivinationAPIApi extends runtime.BaseAPI {

    /**
     * Check if divination has been done
     */
    async checkDivinationDoneRaw(requestParameters: CheckDivinationDoneRequest): Promise<runtime.ApiResponse<DivinationQuestionSolveCheckResponseDto>> {
        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling checkDivinationDone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Guest-ID"] = this.configuration.apiKey("X-Guest-ID"); // 유저 식별 Key authentication
        }

        const response = await this.request({
            path: `/v1/divination/questions/{questionId}/check`.replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationQuestionSolveCheckResponseDtoFromJSON(jsonValue));
    }

    /**
     * Check if divination has been done
     */
    async checkDivinationDone(requestParameters: CheckDivinationDoneRequest): Promise<DivinationQuestionSolveCheckResponseDto> {
        const response = await this.checkDivinationDoneRaw(requestParameters);
        return await response.value();
    }

    /**
     * Divination do
     */
    async doDivinationRaw(requestParameters: DoDivinationRequest): Promise<runtime.ApiResponse<DefaultResponse>> {
        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling doDivination.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Guest-ID"] = this.configuration.apiKey("X-Guest-ID"); // 유저 식별 Key authentication
        }

        const response = await this.request({
            path: `/v1/divination/questions/{questionId}`.replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DefaultResponseFromJSON(jsonValue));
    }

    /**
     * Divination do
     */
    async doDivination(requestParameters: DoDivinationRequest): Promise<DefaultResponse> {
        const response = await this.doDivinationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get divination question detail
     */
    async getDivinationQuestionDetailRaw(requestParameters: GetDivinationQuestionDetailRequest): Promise<runtime.ApiResponse<DivinationQuestionResponseDto>> {
        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling getDivinationQuestionDetail.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Guest-ID"] = this.configuration.apiKey("X-Guest-ID"); // 유저 식별 Key authentication
        }

        const response = await this.request({
            path: `/v1/divination/questions/{questionId}`.replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationQuestionResponseDtoFromJSON(jsonValue));
    }

    /**
     * Get divination question detail
     */
    async getDivinationQuestionDetail(requestParameters: GetDivinationQuestionDetailRequest): Promise<DivinationQuestionResponseDto> {
        const response = await this.getDivinationQuestionDetailRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get divinations
     */
    async getDivinationQuestionsRaw(requestParameters: GetDivinationQuestionsRequest): Promise<runtime.ApiResponse<DivinationQuestionListResponseDto>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling getDivinationQuestions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.request !== undefined) {
            queryParameters['request'] = requestParameters.request;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Guest-ID"] = this.configuration.apiKey("X-Guest-ID"); // 유저 식별 Key authentication
        }

        const response = await this.request({
            path: `/v1/divination/questions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationQuestionListResponseDtoFromJSON(jsonValue));
    }

    /**
     * Get divinations
     */
    async getDivinationQuestions(requestParameters: GetDivinationQuestionsRequest): Promise<DivinationQuestionListResponseDto> {
        const response = await this.getDivinationQuestionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get divination result
     */
    async getDivinationResultRaw(requestParameters: GetDivinationResultRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.resultId === null || requestParameters.resultId === undefined) {
            throw new runtime.RequiredError('resultId','Required parameter requestParameters.resultId was null or undefined when calling getDivinationResult.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Guest-ID"] = this.configuration.apiKey("X-Guest-ID"); // 유저 식별 Key authentication
        }

        const response = await this.request({
            path: `/v1/divination/results/{resultId}`.replace(`{${"resultId"}}`, encodeURIComponent(String(requestParameters.resultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get divination result
     */
    async getDivinationResult(requestParameters: GetDivinationResultRequest): Promise<void> {
        await this.getDivinationResultRaw(requestParameters);
    }

}
