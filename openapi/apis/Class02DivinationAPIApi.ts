/* tslint:disable */
/* eslint-disable */
/**
 * 냥팔자 API 명세
 * 냥파자는 상팔자 어플리케이션을 위한 API 명세서입니다. - 모든 API의 Path는 **\'/api\'로 시작**합니다. - 모든 API의 응답은 **공통 응답 형식**을 가집니다. data에 실제 응답 데이터가 들어갑니다.     ```json     {       \"requestId\": \"서버생성 요청ID\",       \"requestTime\": \"요청시간\",       \"success\": \"성공여부\",       \"data\": {         JSON 데이터       }     }     ```
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    DivinationQuestionListReqeustDto,
    DivinationQuestionListReqeustDtoFromJSON,
    DivinationQuestionListReqeustDtoToJSON,
    DivinationQuestionListResponseDto,
    DivinationQuestionListResponseDtoFromJSON,
    DivinationQuestionListResponseDtoToJSON,
    DivinationQuestionResponseDto,
    DivinationQuestionResponseDtoFromJSON,
    DivinationQuestionResponseDtoToJSON,
    DivinationQuestionSolveCheckResponseDto,
    DivinationQuestionSolveCheckResponseDtoFromJSON,
    DivinationQuestionSolveCheckResponseDtoToJSON,
    DivinationResultResponseDto,
    DivinationResultResponseDtoFromJSON,
    DivinationResultResponseDtoToJSON,
    DivinationSalResultResponseDto,
    DivinationSalResultResponseDtoFromJSON,
    DivinationSalResultResponseDtoToJSON,
} from '../models';

export interface CheckDivinationDoneRequest {
    questionId: number;
}

export interface GetDivinationQuestionDetailRequest {
    questionId: number;
}

export interface GetDivinationQuestionsRequest {
    request: DivinationQuestionListReqeustDto;
}

export interface GetDivinationResultRequest {
    resultId: number;
}

export interface TakeDivinationRequest {
    questionId: number;
}

/**
 * 
 */
export class Class02DivinationAPIApi extends runtime.BaseAPI {

    /**
     * 사주/질문을 본 적 있는지 확인합니다
     */
    async checkDivinationDoneRaw(requestParameters: CheckDivinationDoneRequest): Promise<runtime.ApiResponse<DivinationQuestionSolveCheckResponseDto>> {
        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling checkDivinationDone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("JWT Token", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/divination/questions/{questionId}/check`.replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationQuestionSolveCheckResponseDtoFromJSON(jsonValue));
    }

    /**
     * 사주/질문을 본 적 있는지 확인합니다
     */
    async checkDivinationDone(requestParameters: CheckDivinationDoneRequest): Promise<DivinationQuestionSolveCheckResponseDto> {
        const response = await this.checkDivinationDoneRaw(requestParameters);
        return await response.value();
    }

    /**
     * 사주/타로 질문의 상세 정보를 가져옵니다.
     */
    async getDivinationQuestionDetailRaw(requestParameters: GetDivinationQuestionDetailRequest): Promise<runtime.ApiResponse<DivinationQuestionResponseDto>> {
        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling getDivinationQuestionDetail.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/divination/questions/{questionId}`.replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationQuestionResponseDtoFromJSON(jsonValue));
    }

    /**
     * 사주/타로 질문의 상세 정보를 가져옵니다.
     */
    async getDivinationQuestionDetail(requestParameters: GetDivinationQuestionDetailRequest): Promise<DivinationQuestionResponseDto> {
        const response = await this.getDivinationQuestionDetailRaw(requestParameters);
        return await response.value();
    }

    /**
     * 사주/타로 질문 리스트를 가져옵니다.
     */
    async getDivinationQuestionsRaw(requestParameters: GetDivinationQuestionsRequest): Promise<runtime.ApiResponse<DivinationQuestionListResponseDto>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling getDivinationQuestions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.request !== undefined) {
            queryParameters['request'] = requestParameters.request;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/divination/questions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationQuestionListResponseDtoFromJSON(jsonValue));
    }

    /**
     * 사주/타로 질문 리스트를 가져옵니다.
     */
    async getDivinationQuestions(requestParameters: GetDivinationQuestionsRequest): Promise<DivinationQuestionListResponseDto> {
        const response = await this.getDivinationQuestionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get divination result
     */
    async getDivinationResultRaw(requestParameters: GetDivinationResultRequest): Promise<runtime.ApiResponse<DivinationSalResultResponseDto>> {
        if (requestParameters.resultId === null || requestParameters.resultId === undefined) {
            throw new runtime.RequiredError('resultId','Required parameter requestParameters.resultId was null or undefined when calling getDivinationResult.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("JWT Token", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/divination/results/{resultId}`.replace(`{${"resultId"}}`, encodeURIComponent(String(requestParameters.resultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationSalResultResponseDtoFromJSON(jsonValue));
    }

    /**
     * Get divination result
     */
    async getDivinationResult(requestParameters: GetDivinationResultRequest): Promise<DivinationSalResultResponseDto> {
        const response = await this.getDivinationResultRaw(requestParameters);
        return await response.value();
    }

    /**
     * 오늘의 추천 사주 질문을 가져옵니다.
     */
    async getRecommendDivinationRaw(): Promise<runtime.ApiResponse<DivinationQuestionResponseDto>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/divination/recommend`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationQuestionResponseDtoFromJSON(jsonValue));
    }

    /**
     * 오늘의 추천 사주 질문을 가져옵니다.
     */
    async getRecommendDivination(): Promise<DivinationQuestionResponseDto> {
        const response = await this.getRecommendDivinationRaw();
        return await response.value();
    }

    /**
     * 오늘의 운세 사주를 봅니다.
     */
    async takeDailyFortuneRaw(): Promise<runtime.ApiResponse<DivinationResultResponseDto>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("JWT Token", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/divination/daily-fortune`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationResultResponseDtoFromJSON(jsonValue));
    }

    /**
     * 오늘의 운세 사주를 봅니다.
     */
    async takeDailyFortune(): Promise<DivinationResultResponseDto> {
        const response = await this.takeDailyFortuneRaw();
        return await response.value();
    }

    /**
     * 사주/타로를 봅니다.
     */
    async takeDivinationRaw(requestParameters: TakeDivinationRequest): Promise<runtime.ApiResponse<DivinationSalResultResponseDto>> {
        if (requestParameters.questionId === null || requestParameters.questionId === undefined) {
            throw new runtime.RequiredError('questionId','Required parameter requestParameters.questionId was null or undefined when calling takeDivination.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = typeof token === 'function' ? token("JWT Token", []) : token;

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/divination/questions/{questionId}`.replace(`{${"questionId"}}`, encodeURIComponent(String(requestParameters.questionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DivinationSalResultResponseDtoFromJSON(jsonValue));
    }

    /**
     * 사주/타로를 봅니다.
     */
    async takeDivination(requestParameters: TakeDivinationRequest): Promise<DivinationSalResultResponseDto> {
        const response = await this.takeDivinationRaw(requestParameters);
        return await response.value();
    }

}
